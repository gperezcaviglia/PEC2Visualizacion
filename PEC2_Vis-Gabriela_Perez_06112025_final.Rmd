---
title: 'Visualización de datos: PEC2'
author: "Autor: Gabriela Alejandra Perez"
date: "Fecha de entrega: 06 de Noviembre 2025"
output:
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
    includes:
      in_header: 75.584-PEC-header.html
  header-includes:
  - \usepackage{booktabs}
  - \usepackage{sectsty} \sectionfont{\centering \emph}
  pdf_document:
    highlight: zenburn
    toc: yes
  word_document: default
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

------------------------------------------------------------------------

# Técnica de visualización específica/infrecuente: Sparklines

------------------------------------------------------------------------

## Definición general

### Nombre y Origen

Los **sparklines** o **minigráficos** son representaciones gráficas pequeñas, simples y de alta resolución diseñadas para ser integradas en líneas de texto, tablas o dashboards. El término fue acuñado por **Edward Tufte** en su influyente libro *"Beautiful Evidence"* publicado en **2006**, donde los describe como "gráficos de datos intensos, simples, del tamaño de una palabra".

### Descripción y Características

Un sparkline es esencialmente un gráfico despojado de todos los elementos tradicionales: sin ejes, sin etiquetas, sin leyendas y sin cuadrícula. Su filosofía de diseño se basa en el principio de **máxima densidad de información en mínimo espacio**. Como Tufte establece, son "pequeños, intensos, simples, con alta resolución de palabras, números e imágenes".

**Características distintivas:**

- **Minimalismo extremo:** Elimina todo elemento decorativo o no esencial
- **Integración contextual:** Se diseña para convivir con texto y números
- **Comparación rápida:** Permite ver múltiples tendencias simultáneamente
- **Interpretación inmediata:** La comprensión es casi instantánea
- **Alta densidad de datos:** Puede representar cientos de puntos en pocos centímetros

### Funcionamiento

Los sparklines funcionan mediante la representación visual de series temporales en un espacio muy reducido, típicamente entre 150-250 píxeles de ancho y 30-80 píxeles de alto. Pueden adoptar tres formas principales:

1. **Sparkline de línea:** Muestra la evolución continua de una variable
2. **Sparkline de barras:** Representa valores discretos como columnas
3. **Sparkline de ganancia/pérdida:** Destaca cambios positivos y negativos

El principio fundamental es que el usuario puede captar la **forma general de la tendencia** sin necesidad de leer valores exactos, aunque estos pueden estar disponibles mediante interacción (tooltips).

### Ejemplos Típicos de Aplicación

Los sparklines han encontrado aplicación en diversos contextos profesionales:

- **Finanzas:** Visualización de cotizaciones bursátiles en tablas de múltiples acciones
- **Análisis empresarial:** Dashboards ejecutivos con KPIs y tendencias de ventas
- **Monitoreo de sistemas:** Rendimiento de servidores, uso de CPU, tráfico de red
- **Periodismo de datos:** Infografías y tablas comparativas en medios digitales
- **Comercio electrónico:** Evolución de precios en comparadores y marketplaces
- **Salud pública:** Seguimiento de indicadores epidemiológicos
- **Deportes:** Estadísticas de rendimiento de atletas a lo largo de temporadas

Empresas como **Google Finance**, **Bloomberg Terminal**, y plataformas de análisis como **Tableau** y **Power BI** han incorporado sparklines como elemento estándar en sus interfaces.

---

## Tipo y estructura de datos adecuados

### Tipos de Datos

Los sparklines son específicamente adecuados para:

**Datos cuantitativos:**

- Series temporales continuas (precios, temperaturas, visitas web)
- Datos ordenados cronológicamente con intervalos regulares
- Variables numéricas con tendencias claras

**No son adecuados para:**

- Datos categóricos sin orden temporal
- Variables cualitativas
- Datos con múltiples series que requieren comparación directa entre sí en un mismo gráfico

### Estructura de Datos Requerida

La estructura ideal para sparklines consiste en una tabla con dos columnas básicas:

| Fecha/Período | Valor |
|---------------|-------|
| 2024-01-01    | 150.5 |
| 2024-01-02    | 152.3 |
| 2024-01-03    | 151.8 |
| ...           | ...   |

**Requisitos específicos:**

- **Frecuencia temporal:** Datos con intervalos regulares (diarios, semanales, mensuales)
- **Continuidad:** Series sin interrupciones significativas que distorsionen la tendencia
- **Valores numéricos:** Exclusivamente datos cuantitativos
- **Orden cronológico:** Los datos deben estar ordenados temporalmente

### Limitaciones de Tamaño

**Tamaño mínimo del conjunto de datos:**

- **Mínimo recomendado:** 10-15 puntos de datos
- **Por debajo de 10 puntos:** La tendencia puede no ser evidente y un simple texto con porcentaje de cambio sería más efectivo

**Tamaño máximo del conjunto de datos:**

- **Máximo recomendado:** 100-200 puntos de datos
- **Razón:** Más allá de este límite, los detalles se pierden debido al tamaño reducido del gráfico y la visualización pierde efectividad

**Consideraciones adicionales:**

- **Volatilidad:** Series muy volátiles pueden resultar en sparklines difíciles de interpretar; en estos casos, suavizado de datos puede ser necesario
- **Escala:** Todos los sparklines en una tabla comparativa deberían idealmente usar la misma escala vertical para permitir comparación visual directa, aunque esto no siempre es práctico
- **Outliers:** Valores atípicos extremos pueden comprimir el resto de la serie; considerar normalización o exclusión justificada

---

## Visualización práctica: SPARKLINE DE BARRAS - Evolución continua de una variable

### Descripción del Dataset Utilizado

Para esta visualización práctica, he seleccionado datos del **mercado de valores estadounidense**, específicamente las **10 principales empresas tecnológicas** por capitalización de mercado. Los datos provienen de **Yahoo Finance** y abarcan un período de **12 meses** (noviembre 2024 - noviembre 2025).

**Características del dataset:**

- **Fuente:** Yahoo Finance API  
- **Período:** 365 días (datos diarios)  
- **Variable:** Precio de cierre ajustado en dólares estadounidenses  
- **Empresas incluidas:** AAPL (Apple), MSFT (Microsoft), GOOGL (Alphabet/Google), AMZN (Amazon), TSLA (Tesla), META (Meta/Facebook), NVDA (NVIDIA), NFLX (Netflix), ADBE (Adobe), CRM (Salesforce)

```{r sparkline1, echo=FALSE, results='asis', message=FALSE, warning=FALSE}

knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

# Configurar quantmod para evitar plots automáticos
options("getSymbols.warning4.0" = FALSE)
options("getSymbols.auto.assign" = FALSE)

# Cargar todas las librerías
library(readr)
library(dplyr)
library(visNetwork)
library(igraph)
library(knitr)
library(kableExtra)
library(leaflet)
library(geosphere)
library(quantmod)
library(sparkline)
library(htmltools)
library(zoo)


# ============================================
# 1. DEFINIR EMPRESAS
# ============================================
empresas <- c("AAPL", "MSFT", "GOOGL", "AMZN", "TSLA", 
              "META", "NVDA", "NFLX", "ADBE", "CRM")

# ============================================
# 2. OBTENER DATOS Y CREAR SPARKLINES
# ============================================
resultados <- list()

for(ticker in empresas) {
  cat("Procesando:", ticker, "\n")
  
  tryCatch({
    # Descargar datos
    datos <- getSymbols(ticker, 
                        src = "yahoo", 
                        from = Sys.Date() - 365, 
                        to = Sys.Date(), 
                        auto.assign = FALSE)
    
    # Extraer precios
    precios <- as.vector(Cl(datos))
    precios <- precios[!is.na(precios)]
    
    # Calcular métricas
    precio_actual <- tail(precios, 1)
    precio_inicial <- head(precios, 1)
    cambio_pct <- ((precio_actual - precio_inicial) / precio_inicial) * 100
    maximo <- max(precios)
    minimo <- min(precios)
    
    # Crear sparkline
    spark <- sparkline(
      precios,
      type = "line",
      width = 200,
      height = 50,
      lineColor = "#17a2b8",           # Celeste (color principal de la línea)
      fillColor = "#d1ecf1",           # Celeste muy claro (relleno)
      minSpotColor = "#dc3545",        # Rojo (punto mínimo) 
      maxSpotColor = "#28a745",        # Verde (punto máximo) 
      spotColor = "#007bff",           # Azul (punto actual)
      spotRadius = 3,                  # Tamaño de los puntos destacados
      lineWidth = 1                    
    )
    
    # Guardar resultado
    resultados[[ticker]] <- list(
      empresa = ticker,
      precio = round(precio_actual, 2),
      cambio = round(cambio_pct, 2),
      minimo = round(minimo, 2),
      maximo = round(maximo, 2),
      grafico = spark
    )
    
  }, error = function(e) {
    cat("Error con", ticker, ":", e$message, "\n")
  })
}

# ============================================
# 3. CREAR TABLA HTML
# ============================================

# Crear dataframe base
df <- data.frame(
  Empresa = character(),
  Precio = character(),
  Cambio = character(),
  Minimo = character(),
  Maximo = character(),
  stringsAsFactors = FALSE
)

# Llenar dataframe y guardar cambios numéricos
cambios_num <- numeric()

for(i in seq_along(resultados)) {
  res <- resultados[[i]]
  cambio_num <- res$cambio
  cambios_num <- c(cambios_num, cambio_num)
  signo <- ifelse(cambio_num >= 0, "+", "")
  
  df <- rbind(df, data.frame(
    Empresa = res$empresa,
    Precio = paste0("$", res$precio),
    Cambio = paste0(signo, cambio_num, "%"),
    Minimo = paste0("$", res$minimo),
    Maximo = paste0("$", res$maximo),
    stringsAsFactors = FALSE
  ))
}

tabla_html <- tags$table(
  class = "table table-striped table-hover",
  style = "width: 100%; max-width: 1000px; margin: 20px auto; border-collapse: collapse;",
  
  tags$thead(
    tags$tr(
      style = "background-color: #3498db; color: white;",
      tags$th(style = "padding: 12px; text-align: left; border: 1px solid #ddd;", "Empresa"),
      tags$th(style = "padding: 12px; text-align: right; border: 1px solid #ddd;", "Precio Actual"),
      tags$th(style = "padding: 12px; text-align: right; border: 1px solid #ddd;", "Cambio Anual"),
      tags$th(style = "padding: 12px; text-align: right; border: 1px solid #ddd;", "Mínimo"),
      tags$th(style = "padding: 12px; text-align: right; border: 1px solid #ddd;", "Máximo"),
      tags$th(style = "padding: 12px; text-align: center; border: 1px solid #ddd;", "Tendencia (12 meses)")
    )
  ),
  
  tags$tbody(
    lapply(1:nrow(df), function(i) {
      color <- ifelse(cambios_num[i] >= 0, "#28a745", "#dc3545")
      bg <- ifelse(cambios_num[i] >= 0, "#d4edda", "#f8d7da")
      
      tags$tr(
        tags$td(style = "padding: 10px; font-weight: bold; border: 1px solid #ddd;", df$Empresa[i]),
        tags$td(style = "padding: 10px; text-align: right; border: 1px solid #ddd;", df$Precio[i]),
        tags$td(style = paste0("padding: 10px; text-align: right; color: ", color, "; background: ", bg, "; font-weight: bold; border: 1px solid #ddd;"), 
                df$Cambio[i]),
        tags$td(style = "padding: 10px; text-align: right; border: 1px solid #ddd;", df$Minimo[i]),
        tags$td(style = "padding: 10px; text-align: right; border: 1px solid #ddd;", df$Maximo[i]),
        tags$td(style = "padding: 10px; text-align: center; border: 1px solid #ddd;", resultados[[i]]$grafico)
      )
    })
  )
)

# ============================================
# 4. MOSTRAR TABLA
# ============================================
browsable(tagList(tabla_html, sparkline(0)))

```
### Análisis de la Visualización

#### ¿Qué se Representa?

La tabla comparativa muestra el **rendimiento financiero anual** de estas empresas mediante una combinación de datos numéricos y visualización sparkline. Cada fila contiene:

1. **Ticker de la empresa:** Identificador bursátil
2. **Precio actual:** Valor de cierre más reciente en dólares
3. **Cambio anual:** Porcentaje de variación respecto al inicio del período
4. **Mínimo:** Precio más bajo alcanzado en el período
5. **Máximo:** Precio más alto alcanzado en el período
6. **Sparkline:** Representación visual de la evolución diaria del precio

#### Aspectos Específicos que Resalta la Visualización

Los sparklines en esta tabla permiten identificar rápidamente varios patrones clave:

**Tendencias alcistas vs. bajistas:**

- Las empresas con **sparklines verdes** (AAPL, MSFT, GOOGL, AMZN, TSLA, META, NVDA, NFLX) muestran rendimiento positivo anual
- Las empresas con **sparklines rojos** (ADBE, CRM) experimentaron caídas significativas
- La codificación por color proporciona un indicador visual inmediato del rendimiento

**Volatilidad del mercado:**

- **Tesla (TSLA)** muestra el sparkline más volátil, con fluctuaciones pronunciadas que revelan alta incertidumbre y reacciones fuertes a noticias
- **Microsoft (MSFT)** presenta una curva más suave, indicando estabilidad relativa
- **NVIDIA (NVDA)** muestra crecimiento dramático seguido de consolidación, típico de empresas de tecnología emergente

**Puntos de inflexión:**

- Los **puntos rojos** en los sparklines marcan los **mínimos históricos** del período
- Los **puntos verdes** señalan los **máximos históricos**
- Estos puntos permiten identificar rápidamente eventos de mercado significativos

**Recuperación post-caída:**

- Se observan patrones de caída pronunciada seguida de recuperación en varias empresas, posiblemente relacionados con correcciones de mercado
- La visualización hace evidente qué empresas lograron recuperarse completamente vs. aquellas que permanecieron deprimidas

**Comparación de magnitud:**

- Aunque los sparklines no están en la misma escala (cada uno es proporcional a su propio rango), su forma permite comparar la **naturaleza** de las tendencias
- Empresas como **Netflix (NFLX)** con +40.79% y **Adobe (ADBE)** con -33.54% muestran trayectorias opuestas claramente visibles

#### Objetivo Concreto de Comunicación o Descubrimiento

El objetivo principal de esta visualización es proporcionar una **herramienta de análisis comparativo rápido** para inversionistas, analistas financieros o cualquier persona interesada en el sector tecnológico que necesite:

1. **Evaluar rendimiento relativo:** Comparar instantáneamente 10 empresas sin necesidad de abrir 10 gráficos separados
2. **Identificar oportunidades:** Detectar empresas con tendencias alcistas sostenidas o potencial de rebote
3. **Gestionar riesgo:** Visualizar volatilidad histórica antes de tomar decisiones de inversión
4. **Contextualizar números:** Los porcentajes de cambio cobran más significado cuando se ve la trayectoria completa

**Objetivo de descubrimiento:**

La visualización facilita el descubrimiento de patrones no evidentes en tablas puramente numéricas:

- **Sincronización de mercado:** Varias empresas muestran caídas simultáneas, sugiriendo eventos macroeconómicos
- **Divergencia sectorial:** Dentro del sector tech, hay ganadores y perdedores claros
- **Timing de inversión:** Los mínimos y máximos visibles pueden informar estrategias de entrada/salida

#### Cómo la Técnica y los Datos Permiten Alcanzar el Objetivo

La combinación de sparklines con datos bursátiles es particularmente efectiva por varias razones:

**Eficiencia espacial:**

- Una sola tabla con sparklines reemplaza lo que serían 10 gráficos de línea completos
- El usuario puede ver toda la información en una pantalla sin necesidad de scroll extensivo
- Ideal para dashboards ejecutivos donde el espacio es limitado

**Velocidad de comprensión:**

- Un ejecutivo puede evaluar el rendimiento del sector tech en **5-10 segundos**
- La forma de la curva se procesa visualmente más rápido que leer una lista de números
- La codificación por color (verde/rojo) proporciona señales inmediatas de alerta o confirmación

**Contexto numérico + visual:**

- Los sparklines no reemplazan los números, los **complementan**
- Un cambio de +21.29% (AAPL) cobra más significado al ver que fue resultado de volatilidad y recuperación, no crecimiento lineal
- Los valores mínimo y máximo permiten calcular mentalmente rangos de fluctuación

**Detección de patrones:**

- Patrones en forma de "V" (caída-recuperación) son inmediatamente reconocibles
- Tendencias sostenidas vs. picos aislados son distinguibles de un vistazo
- Anomalías o eventos extremos se destacan naturalmente

**Comparabilidad:**

- La disposición tabular con sparklines alineados verticalmente facilita la comparación visual
- El usuario puede rápidamente identificar cuál empresa tuvo la trayectoria más favorable
- Patrones comunes entre empresas del mismo sector se hacen evidentes

**Interactividad (en implementación web):**

- Al pasar el cursor sobre los sparklines, se pueden mostrar valores exactos mediante tooltips
- Esto combina la rapidez de la visualización general con la precisión cuando se necesita

### Limitaciones Reconocidas

Es importante mencionar que esta implementación de sparklines tiene ciertas limitaciones:

- **Diferentes escalas:** Cada sparkline usa su propia escala vertical, lo que dificulta comparar magnitudes absolutas de volatilidad
- **Sin contexto de volumen:** No muestra volumen de transacciones, relevante en análisis bursátil
- **Período fijo:** 12 meses es arbitrario; diferentes horizontes temporales revelarían distintos patrones
- **Sin eventos anotados:** No marca eventos específicos (resultados trimestrales, anuncios de productos) que expliquen movimientos

A pesar de estas limitaciones, la visualización cumple exitosamente su propósito: **proporcionar una visión general comparativa rápida y efectiva del rendimiento del sector tecnológico** que sirve como punto de partida para análisis más profundos cuando se requieren.

## Otras visualizaciones: SPARKLINE DE BARRAS - Volumen Mensual

Los sparklines de barras representan valores discretos mediante columnas verticales. Son ideales para mostrar:

- Volumen de transacciones por período
- Conteo de eventos o actividades
- Métricas que varían significativamente entre períodos

**Ventaja:** Facilitan la comparación de magnitudes relativas entre períodos.

```{r sparkline2, echo=FALSE, results='asis', message=FALSE, warning=FALSE}
## Ejemplo adicional: Sparkline de barras

### Volumen mensual de transacciones
library(quantmod)
library(sparkline)
library(htmltools)
library(zoo)

# Empresas para análisis de volumen
empresas_vol <- c("AAPL", "TSLA", "GME")  # GME para mostrar alta volatilidad

resultados_barras <- list()

for(ticker in empresas_vol) {
  cat("Procesando volumen de:", ticker, "\n")
  
  tryCatch({
    # Descargar datos del último año
    datos <- getSymbols(ticker, 
                        src = "yahoo", 
                        from = Sys.Date() - 365, 
                        to = Sys.Date(), 
                        auto.assign = FALSE)
    
    # Extraer volumen y agregar por mes
    volumen <- Vo(datos)
    volumen_mensual <- apply.monthly(volumen, sum)
    volumen_vec <- as.vector(volumen_mensual) / 1e6  # En millones
    
    # Tomar últimos 12 meses
    volumen_vec <- tail(volumen_vec, 12)
    
    # Crear sparkline de BARRAS
    spark_barras <- sparkline(
      volumen_vec,
      type = "bar",              
      width = 200,
      height = 50,
      barColor = "#17a2b8",      # Celeste
      barWidth = 10,
      barSpacing = 2
    )
    
    # Calcular métricas
    vol_promedio <- round(mean(volumen_vec), 1)
    vol_max <- round(max(volumen_vec), 1)
    
    resultados_barras[[ticker]] <- list(
      empresa = ticker,
      promedio = vol_promedio,
      maximo = vol_max,
      grafico = spark_barras
    )
    
  }, error = function(e) {
    cat("Error con", ticker, "\n")
  })
}

# Crear tabla
tabla_barras <- tags$table(
  class = "table table-striped",
  style = "width: 100%; max-width: 700px; margin: 20px auto; border-collapse: collapse;",
  
  tags$thead(
    tags$tr(
      style = "background-color: #17a2b8; color: white;",
      tags$th(style = "padding: 12px;", "Empresa"),
      tags$th(style = "padding: 12px; text-align: right;", "Volumen Promedio (M)"),
      tags$th(style = "padding: 12px; text-align: right;", "Volumen Máximo (M)"),
      tags$th(style = "padding: 12px; text-align: center;", "Volumen Mensual (12 meses)")
    )
  ),
  
  tags$tbody(
    lapply(1:length(resultados_barras), function(i) {
      res <- resultados_barras[[i]]
      tags$tr(
        tags$td(style = "padding: 10px; font-weight: bold;", res$empresa),
        tags$td(style = "padding: 10px; text-align: right;", paste0(res$promedio, "M")),
        tags$td(style = "padding: 10px; text-align: right;", paste0(res$maximo, "M")),
        tags$td(style = "padding: 10px; text-align: center;", res$grafico)
      )
    })
  )
)

browsable(tagList(tabla_barras, sparkline(0)))


```

## Otras visualizaciones: SPARKLINE WIN/LOSS - Rendimiento Mensual

Los sparklines de ganancia/pérdida (también llamados "tristate") representan valores positivos, negativos y neutros mediante barras de colores. Son útiles para:

- Identificar rachas de éxito o fracaso
- Visualizar consistencia de resultados
- Detectar patrones de alternancia

**Ventaja:** Resalta inmediatamente períodos favorables vs. desfavorables sin necesidad de leer números.

```{r sparkline3, echo=FALSE, results='asis', message=FALSE, warning=FALSE}
## Ejemplo adicional: Sparkline de ganancia/pérdida

### Rendimiento mensual positivo/negativo
library(quantmod)
library(sparkline)
library(htmltools)
library(zoo)

# Empresas para análisis mensual
empresas_mensual <- c("NVDA", "ADBE", "CRM")

resultados_winloss <- list()

for(ticker in empresas_mensual) {
  cat("Procesando rendimiento mensual de:", ticker, "\n")
  
  tryCatch({
    # Descargar datos del último año
    datos <- getSymbols(ticker, 
                        src = "yahoo", 
                        from = Sys.Date() - 365, 
                        to = Sys.Date(), 
                        auto.assign = FALSE)
    
    # Calcular rendimiento mensual
    precios_mensuales <- to.monthly(datos)
    precios_cierre <- Cl(precios_mensuales)
    
    # Calcular cambio porcentual mensual
    rendimiento_mensual <- diff(precios_cierre) / lag(precios_cierre) * 100
    rendimiento_mensual <- na.omit(rendimiento_mensual)
    rendimiento_vec <- as.vector(rendimiento_mensual)
    
    # Tomar últimos 12 meses
    rendimiento_vec <- tail(rendimiento_vec, 12)
    
    # Contar meses positivos
    meses_positivos <- sum(rendimiento_vec > 0)
    meses_negativos <- sum(rendimiento_vec < 0)
    
    # Crear sparkline de GANANCIA/PÉRDIDA
    spark_winloss <- sparkline(
      rendimiento_vec,
      type = "tristate",         
      width = 200,
      height = 50,
      posBarColor = "#28a745",   # Verde para ganancias
      negBarColor = "#dc3545",   # Rojo para pérdidas
      zeroBarColor = "#6c757d",  # Gris para neutro
      barWidth = 12,
      barSpacing = 2
    )
    
    resultados_winloss[[ticker]] <- list(
      empresa = ticker,
      positivos = meses_positivos,
      negativos = meses_negativos,
      grafico = spark_winloss
    )
    
  }, error = function(e) {
    cat("Error con", ticker, "\n")
  })
}

# Crear tabla
tabla_winloss <- tags$table(
  class = "table table-striped",
  style = "width: 100%; max-width: 700px; margin: 20px auto; border-collapse: collapse;",
  
  tags$thead(
    tags$tr(
      style = "background-color: #6c757d; color: white;",
      tags$th(style = "padding: 12px;", "Empresa"),
      tags$th(style = "padding: 12px; text-align: center;", "Meses ↑"),
      tags$th(style = "padding: 12px; text-align: center;", "Meses ↓"),
      tags$th(style = "padding: 12px; text-align: center;", "Rendimiento Mensual (12 meses)")
    )
  ),
  
  tags$tbody(
    lapply(1:length(resultados_winloss), function(i) {
      res <- resultados_winloss[[i]]
      tags$tr(
        tags$td(style = "padding: 10px; font-weight: bold;", res$empresa),
        tags$td(style = "padding: 10px; text-align: center; color: #28a745; font-weight: bold;", 
                paste0(res$positivos, " meses")),
        tags$td(style = "padding: 10px; text-align: center; color: #dc3545; font-weight: bold;", 
                paste0(res$negativos, " meses")),
        tags$td(style = "padding: 10px; text-align: center;", res$grafico)
      )
    })
  )
)

browsable(tagList(tabla_winloss, sparkline(0)))
```

---

## Conclusiones sobre Sparklines

Los sparklines demuestran el poder del **diseño minimalista orientado a la información**. En contextos donde se necesita comparar múltiples series temporales simultáneamente con espacio limitado, los sparklines son superiores a gráficos tradicionales. Su efectividad se maximiza cuando:

1. El objetivo es comunicar **tendencias generales**, no valores exactos
2. Se necesita **densidad de información** en espacio reducido
3. La audiencia requiere **comprensión rápida** más que análisis profundo
4. Se busca **integración con datos numéricos** en tablas o textos

La visualización presentada ejemplifica cómo esta técnica, originada en el diseño de información impreso, se traduce efectivamente al medio digital interactivo, manteniendo su esencia de simplicidad y claridad comunicativa.

------------------------------------------------------------------------

# Técnica de visualización avanzada: Diagrama de Red

------------------------------------------------------------------------

## Definición general

### Nombre y Origen

El **Diagrama de Red** también conocido como **grafo**, es una representación visual de las relaciones y conexiones entre entidades. Su origen conceptual se remonta a la **Teoría de Grafos**, una rama de las matemáticas fundada por **Leonhard Euler en 1736**.

El trabajo seminal de Euler resolvió el famoso problema de los **Siete Puentes de Königsberg**, demostrando que era imposible cruzar los siete puentes de la ciudad exactamente una vez. Al abstraer el problema a un conjunto de puntos (masas de tierra) y líneas (puentes), Euler sentó las bases para el análisis de cualquier sistema definido por sus relaciones.

### Descripción y Características

Un diagrama de red representa un conjunto de objetos (nodos) y las conexiones entre ellos (aristas).

- **Nodos (Nodes o Vértices):** Son las entidades individuales del sistema. (Ej. aeropuertos, personas, acciones financieras).
- **Aristas (Edges o Enlaces):** Son las líneas que conectan los nodos, representando la relación entre ellos. (Ej. una ruta de vuelo, una amistad, una correlación).

**Características distintivas:**

- **Enfoque en la Topología:** Su principal valor es revelar la estructura y forma de la red (su topología).
- **Centralidad:** Identifica visualmente qué nodos son más importantes o están mejor conectados (hubs).
- **Clustering:** Muestra grupos de nodos que están densamente conectados entre sí (comunidades o clusters).
- **Atributos codificados:** El tamaño, color o forma de los nodos y el grosor o color de las aristas pueden codificar variables adicionales (ej. tráfico de pasajeros, región geográfica).

### Funcionamiento

Los diagramas de red funcionan mediante algoritmos de disposición (layouts) que posicionan los nodos en el espacio bidimensional. El objetivo es organizar la red de una manera que la haga legible y resalte sus propiedades estructurales.

### Ejemplos Típicos de Aplicación

Los diagramas de red son fundamentales en casi cualquier dominio que estudie sistemas complejos:

- **Sociología:** Análisis de redes sociales (ej. conexiones de amigos en Facebook, retweets en Twitter)
- **Transporte:** Visualización de rutas aéreas, marítimas o de metro para identificar hubs y cuellos de botella.
- **Biología** Mapas de interacción de proteínas o redes neuronales.
- **Finanzas:** Redes de correlación entre acciones o flujos de transacciones.
- **Cienicas de la Compotación:** Topología de Internet, conexiones entre sitios web o dependencias de software.

---

## Tipo y estructura de datos adecuados

### Tipos de Datos

Los diagramas de red están diseñados para datos relacionales. Requieren identificar tanto las entidades como sus conexiones.

- **Nodos (Cuantitativos o Categóricos):** Los atributos de los nodos pueden ser categóricos (ej. group = "California") o cuantitativos (ej. value = 15 conexiones).

- **Aristas (Cuantitativos):** Las aristas son casi siempre cuantitativas, representando la "fuerza" de la relación (ej. value = 5,000,000 pasajeros, weight = 0.8 correlación).

### Estructura de Datos Requerida

Para construir un diagrama de red, se necesitan fundamentalmente dos tablas (o dataframes):

- Una lista de **Nodos**: Un inventario de todas las entidades únicas en la red.

- Una lista de **Aristas**: Una lista de todas las conexiones entre esas entidades.

### Limitaciones de Tamaño

**Tamaño mínimo del conjunto de datos:**

- El gráfico más simple requiere al menos 2 nodos y 1 arista para mostrar una relación.

**Tamaño máximo del conjunto de datos (el problema Hairball):**

- La legibilidad de un diagrama de red no depende tanto del número de nodos, sino de la densidad de aristas.

- **"Bola de Pelos" (Hairball):** Este es el principal desafío de la técnica. Ocurre cuando la red es demasiado densa (demasiadas aristas conectando los nodos). El algoritmo de fuerza colapsa y el gráfico se vuelve una mancha ilegible.

  **Límite Práctico:** Aunque se pueden trazar miles de nodos, para una visualización estática o interactiva simple (como visNetwork), las redes se vuelven difíciles de interpretar por encima de 100-200 nodos si la densidad es alta.

## Visualización práctica

### Descripción del Dataset

Para esta visualización he utilizado el dataset **USA Airport Flight Routes** de Kaggle, que contiene información detallada sobre rutas aéreas comerciales entre aeropuertos de Estados Unidos, incluyendo número de pasajeros, vuelos y distancias.

**Fuente:** Kaggle - USA Airport Dataset  
**URL:** https://www.kaggle.com/datasets/flashgordon/usa-airport-dataset  
**Período:** 1990-2009  
**Registros:** Más de 3 millones de vuelos

```{r cargar-datos-red, message=FALSE, warning=FALSE, cache=TRUE}
# Instalar paquetes necesarios para el diagrama de red

library(readr)
library(dplyr)
library(dplyr)
library(visNetwork)
library(igraph)
library(knitr)
library(kableExtra)
library(leaflet)
library(geosphere)

# Leer el archivo (ajusta el nombre si es diferente)
datos_vuelos <- read_csv("Airports2.csv", show_col_types = FALSE)

# Ver estructura
cat("Total de registros de vuelos:", nrow(datos_vuelos), "\n")
cat("Columnas disponibles:", paste(names(datos_vuelos), collapse = ", "), "\n")

# Ver primeras filas
head(datos_vuelos, 3)
```

### Red de Conexiones entre Aeropuertos Principales de USA

```{r preparar-datos-red, message=FALSE, warning=FALSE}
library(dplyr)
library(leaflet)
library(geosphere)
library(readr)
# ============================================
# 1. EXTRAER AEROPUERTOS ÚNICOS
# ============================================

# Obtener aeropuertos de origen
aeropuertos_origen <- datos_vuelos %>%
  select(
    codigo = Origin_airport,
    ciudad = Origin_city,
    lat = Org_airport_lat,
    lon = Org_airport_long,
    poblacion = Origin_population
  ) %>%
  distinct()

# Obtener aeropuertos de destino
aeropuertos_destino <- datos_vuelos %>%
  select(
    codigo = Destination_airport,
    ciudad = Destination_city,
    lat = Dest_airport_lat,
    lon = Dest_airport_long,
    poblacion = Destination_population
  ) %>%
  distinct()

# Combinar y eliminar duplicados
aeropuertos_todos <- bind_rows(aeropuertos_origen, aeropuertos_destino) %>%
  group_by(codigo) %>%
  summarise(
    ciudad = first(na.omit(ciudad)),
    lat = first(na.omit(lat)),
    lon = first(na.omit(lon)),
    poblacion = first(na.omit(poblacion)),
    .groups = "drop"
  ) %>%
  filter(!is.na(lat), !is.na(lon)) # Eliminar aeropuertos sin coordenadas

cat("\nTotal de aeropuertos únicos con coordenadas:", nrow(aeropuertos_todos), "\n")

# ============================================
# 2. AGREGAR RUTAS Y FILTRAR
# ============================================

# Agregar datos por ruta (sumar pasajeros, vuelos)
rutas_agregadas <- datos_vuelos %>%
  filter(!is.na(Org_airport_lat), !is.na(Dest_airport_lat)) %>%
  group_by(Origin_airport, Destination_airport) %>%
  summarise(
    total_pasajeros = sum(Passengers, na.rm = TRUE),
    total_vuelos = sum(Flights, na.rm = TRUE),
    distancia = first(Distance),
    .groups = "drop"
  ) %>%
  arrange(desc(total_pasajeros))

# Seleccionar solo los TOP 15 aeropuertos por tráfico
top_aeropuertos <- rutas_agregadas %>%
  group_by(Origin_airport) %>%
  summarise(trafico = sum(total_pasajeros), .groups = "drop") %>%
  arrange(desc(trafico)) %>%
  head(15) %>%
  pull(Origin_airport)

cat("Top 15 aeropuertos por tráfico:", paste(top_aeropuertos, collapse = ", "), "\n")

# Filtrar aeropuertos
aeropuertos_viz <- aeropuertos_todos %>%
  filter(codigo %in% top_aeropuertos)

# Filtrar las 50 rutas más transitadas
rutas_viz <- rutas_agregadas %>%
  filter(
    Origin_airport %in% top_aeropuertos,
    Destination_airport %in% top_aeropuertos
    
  ) %>%
  arrange(desc(total_pasajeros)) %>%
  head(50) 

cat("\nAeropuertos para visualización:", nrow(aeropuertos_viz), "\n")
cat("Rutas para visualización:", nrow(rutas_viz), "\n")
```

### Análisis de la Visualización

#### Estadísticas de la Red

```{r diagrama-red-usa, echo=FALSE, results='asis', message=FALSE, warning=FALSE, fig.width=10, fig.height=8}
library(visNetwork)
library(igraph)

# ============================================
# 3. PREPARAR NODOS
# ============================================

# Calcular número de conexiones por aeropuerto
conexiones <- rutas_viz %>%
  group_by(Origin_airport) %>%
  summarise(num_conexiones = n(), .groups = "drop")

# Crear dataframe de nodos
nodos <- aeropuertos_viz %>%
  left_join(conexiones, by = c("codigo" = "Origin_airport")) %>%
  mutate(
    id = codigo,
    label = codigo,
    value = ifelse(is.na(num_conexiones), 1, num_conexiones),
    title = paste0(
      "<b>", ciudad, "</b><br>",
      "Código: ", codigo, "<br>",
      "Conexiones: ", value, "<br>",
      "Población: ", format(poblacion, big.mark = ",")
    ),
    # Agrupar por región (simplificado por estado extraído de ciudad)
    group = ifelse(grepl("CA", ciudad), "California",
            ifelse(grepl("TX", ciudad), "Texas", 
            ifelse(grepl("FL", ciudad), "Florida",
            ifelse(grepl("NY", ciudad), "Nueva York", "Otro"))))
  ) %>%
  select(id, label, value, title, group)

# ============================================
# 4. PREPARAR ENLACES
# ============================================

# Normalizar valores para grosor de líneas
max_pasajeros <- max(rutas_viz$total_pasajeros)

enlaces <- rutas_viz %>%
  mutate(
    from = Origin_airport,
    to = Destination_airport,
    value = round(total_pasajeros / max_pasajeros * 10) + 1,  # Escala 1-10
    title = paste0(
      from, " → ", to, "<br>",
      "Pasajeros: ", format(total_pasajeros, big.mark = ","), "<br>",
      "Vuelos: ", format(total_vuelos, big.mark = ","), "<br>",
      "Distancia: ", distancia, " millas"
    ),
    color = "#17a2b8"
  ) %>%
  select(from, to, value, title, color)

# ============================================
# 5. CREAR VISUALIZACIÓN
# ============================================

visNetwork(nodos, enlaces, width = "100%", height = "600px") %>%
  visNodes(
    shape = "dot",
    scaling = list(min = 20, max = 50),
    font = list(size = 14, face = "arial", color = "#2c3e50", bold = TRUE),
    borderWidth = 2,
    color = list(
      background = "#e8f4f8",
      border = "#17a2b8",
      highlight = list(background = "#ffc107", border = "#ff9800")
    )
  ) %>%
  visEdges(
    smooth = list(enabled = TRUE, type = "curvedCW", roundness = 0.2),
    color = list(color = "#17a2b8", highlight = "#ff9800"),
    arrows = list(to = list(enabled = FALSE))
  ) %>%
  visGroups(groupname = "California", color = "#e74c3c") %>%
  visGroups(groupname = "Texas", color = "#3498db") %>%
  visGroups(groupname = "Florida", color = "#2ecc71") %>%
  visGroups(groupname = "Nueva York", color = "#9b59b6") %>%
  visGroups(groupname = "Otro", color = "#95a5a6") %>%
  visOptions(
    highlightNearest = list(enabled = TRUE, hover = TRUE, degree = 1),
    nodesIdSelection = TRUE
  ) %>%
  visInteraction(
    navigationButtons = TRUE,
    hover = TRUE,
    tooltipDelay = 100
  ) %>%
  visLayout(randomSeed = 123) %>%
  visPhysics(
    stabilization = TRUE,
    barnesHut = list(gravitationalConstant = -8000, springLength = 200)
  ) %>%
  visLegend(
    width = 0.15,
    position = "right",
    main = "Región"
  )
```

#### ¿Qué se Representa?

Este diagrama de red muestra las **50 rutas aéreas más transitadas** que conectan **15 aeropuestos principales** de Estados Unidos basado en datos históricos de 1990-2009. Cada elemento representa:

- **Nodos (círculos):** Aeropuertos principales (Top 15 p or tráfico total)
- **Tamaño del nodo:** Número de conexiones dentro de estas 50 rutas principales
- **Color del nodo:** Región/estado principal (ej. California, Texas)
- **Enlaces (líneas):** Rutas aéreas (disponibles)Top 50 pasajeros)
- **Grosor del enlace:** Volumen de pasajeros transportados (proporcional)

#### Aspectos Específicos que Resalta

**Hubs principales:**

- Aeropuertos como Atlanta (ATL), Chicago (ORD) y Dallas (DFW) aparecen como nodos grandes y centrales, confirmando su rol como hubs nacionales. El algoritmo de fuerza los empuja al centro porque tienen muchas conexiones de alto tráfico.

**Estructura de la red:**

- La red ya no es una "bola de pelos", sino una estructura "Hub-and-Spoke" (centro y radios). Se ven claramente los hubs principales y las rutas que emanan de ellos.

- Se observa que la red no está completa; muchos aeropuertos (nodos) no están conectados directamente entre sí, sino que deben pasar por un hub, lo cual es el objetivo del filtrado.

**Volumen de tráfico:**

- Las líneas más gruesas (ej. LAX-SFO, LAX-JFK) revelan las "super-autopistas" aéreas, las rutas con mayor volumen de pasajeros.

- El grosor revela la importancia económica y logística de cada ruta.

**Patrones regionales:**

- Los colores (grupos) permiten ver clusters geográficos. El grupo de California (rojo) muestra conexiones muy fuertes entre sus propios aeropuertos (LAX, SFO).

- El layout de fuerza tiende a agrupar nodos del mismo color (región) si tienen fuertes conexiones internas.

#### Objetivo Concreto de Comunicación

El objetivo es **visualizar la jerarquía y estructura escencial**, permitiendo:

1. **Identificar aeropuertos críticos:** Ver qué aeropuertos son centrales para las rutas más importantes
2. **Analizar volumen de tráfico:** Las líneas gruesas muestran dónde se concentra la vasta mayoría del tráfico de pasajeros.
3. **Entender la topología:** Demostrar visualmente el modelo "Hub-and-Spoke" que define la aviación de EE. UU.

#### Cómo la Técnica y los Datos Permiten Alcanzar el Objetivo

**Ventajas del diagrama de red:**

- **Jerarquía visual inmediata:** Al filtrar por las Top 50 rutas, los verdaderos hubs (con más rutas importantes) se distinguen claramente por tamaño y centralidad.
- **Legibilidad:** La red es ahora interpretable. En lugar de un colapso, vemos una estructura clara que puede ser analizada.
- **Información cuantitativa:** El grosor de las líneas (aristas) sigue añadiendo la dimensión de volumen de pasajeros.
- **Exploración interactiva:** visNetwork permite seleccionar un aeropuerto (nodo) y resalta inmediatamente su red de conexiones principales.

**Efectividad con datos reales:**

- Basado en millones de registros, el filtrado (head(50)) actúa como un "zoom" en las relaciones más significativas.
- Los datos agregados (pasajeros, vuelos) dan contexto cuantitativo a la estructura.
- La red resultante (15 nodos, 50 aristas) es manejable, legible y altamente representativa de la "columna vertebral" del sistema aéreo.

**Limitaciones reconocidas:**

A pesar de la mejora, esta visualización tiene limitaciones:

- Pérdida de información: Al filtrar, perdemos el 99% de las rutas. Esta vista no muestra aeropuertos regionales o rutas menos transitadas, que son vitales para la conectividad total.

- Datos históricos: Los datos (1990-2009) pueden no reflejar la estructura actual (ej. el crecimiento de hubs como Seattle o el impacto de aerolíneas de bajo coste).

- Layout no geográfico: La posición de los nodos (ej. NY y LA pueden aparecer cerca) es determinada por la física, no por la geografía, lo que puede confundir. (Nota: El mapa de Leaflet que sigue resuelve esta limitación).

- Tamaño de Nodos: El tamaño del nodo se basa en el número de conexiones dentro del Top 50, no en su tráfico total o conexiones totales.

```{r mapa-red-usa, echo=FALSE}
library(dplyr)
library(leaflet)
library(geosphere)
library(readr)

# ============================================
# PREPARAR DATOS PARA MAPA
# ============================================

# Nodos con coordenadas
nodos_mapa <- aeropuertos_viz %>%
  left_join(conexiones, by = c("codigo" = "Origin_airport")) %>%
  mutate(
    num_conexiones = ifelse(is.na(num_conexiones), 1, num_conexiones)
  )

rutas_mapa <- rutas_viz

# ============================================
# CREAR PALETA DE COLORES
# ============================================

pal <- colorNumeric(
  palette = c("#3498db", "#17a2b8", "#f39c12", "#e74c3c"),
  domain = rutas_mapa$total_pasajeros
)

# ============================================
# CREAR MAPA BASE
# ============================================

mapa <- leaflet(width = "100%", height = "600px") %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  setView(lng = -95, lat = 39, zoom = 4)

# ============================================
# AÑADIR RUTAS CON COLORES SEGÚN TRÁFICO
# ============================================

for(i in 1:nrow(rutas_mapa)) {
  origen <- nodos_mapa %>% filter(codigo == rutas_mapa$Origin_airport[i])
  destino <- nodos_mapa %>% filter(codigo == rutas_mapa$Destination_airport[i])
  
  if(nrow(origen) > 0 & nrow(destino) > 0) {
    # Calcular línea curva (great circle)
    ruta_curva <- gcIntermediate(
      c(origen$lon, origen$lat),
      c(destino$lon, destino$lat),
      n = 50,
      addStartEnd = TRUE
    )
    
    # Grosor basado en pasajeros
    grosor <- 1 + (rutas_mapa$total_pasajeros[i] / max(rutas_mapa$total_pasajeros)) * 5
    
    # Añadir línea con color según tráfico
    mapa <- mapa %>%
      addPolylines(
        lng = ruta_curva[,1],
        lat = ruta_curva[,2],
        color = pal(rutas_mapa$total_pasajeros[i]),
        weight = grosor,
        opacity = 0.7,
        popup = paste0(
          "<b>", rutas_mapa$Origin_airport[i], " → ", 
          rutas_mapa$Destination_airport[i], "</b><br>",
          "Pasajeros: ", format(rutas_mapa$total_pasajeros[i], big.mark = ","), "<br>",
          "Vuelos: ", format(rutas_mapa$total_vuelos[i], big.mark = ","), "<br>",
          "Distancia: ", rutas_mapa$distancia[i], " millas"
        )
      )
  }
}

# ============================================
# AÑADIR AEROPUERTOS
# ============================================

mapa <- mapa %>%
  addCircleMarkers(
    data = nodos_mapa,
    lng = ~lon,
    lat = ~lat,
    radius = ~sqrt(num_conexiones) * 3,
    color = "#2c3e50",
    fillColor = "#e74c3c",
    fillOpacity = 0.7,
    weight = 2,
    popup = ~paste0(
      "<b>", ciudad, "</b><br>",
      "Código: ", codigo, "<br>",
      "Conexiones: ", num_conexiones, "<br>",
      "Población: ", format(poblacion, big.mark = ",")
    ),
    label = ~codigo,
    labelOptions = labelOptions(
      noHide = TRUE,
      direction = "top",
      style = list(
        "font-weight" = "bold",
        "font-size" = "12px"
      )
    )
  )

# ============================================
# AÑADIR LEYENDA CON ESCALA
# ============================================

mapa <- mapa %>%
  leaflet::addLegend(
    position = "bottomright",
    pal = pal,
    values = rutas_mapa$total_pasajeros,
    title = "Volumen de<br>Pasajeros",
    opacity = 0.8,
    labFormat = leaflet::labelFormat(
      big.mark = ",",
      digits = 0
    )
  )

# Mostrar mapa
mapa
```

## Conclusiones sobre Diagramas de Red

Los diagramas de red son la técnica óptima para visualizar **sistemas de conexiones y relaciones** donde la estructura es tan importante como las entidades individuales. Son superiores cuando:

1. Las **relaciones entre elementos** son el foco principal del análisis
2. Se necesita identificar **nodos centrales** (hubs) o **comunidades** (clusters)
3. La **topología de la red** revela insights no visibles en tablas
4. La **exploración interactiva** (cómo está "cableada") revela insights no visibles en tablas.

El principal desafío es la **densidad**, que conduce a gráficos ilegibles ("hairballs"). Esta visualización demuestra cómo el **filtrado estratégico** de datos (Top 15 nodos, Top 50 aristas) es una técnica esencial para "podar" la red, resolver el colapso visual y transformar millones de registros en una representación comprensible que revela la arquitectura central del sistema.

------------------------------------------------------------------------

# Técnica de visualización básica: Cartograma

------------------------------------------------------------------------

## Definición general

### Nombre y Origen

Un **Cartograma** es un tipo de visualización geoespacial que distorsiona la forma o el área de las unidades geográficas (como países, estados o provincias) para representar una variable de datos específica. En un cartograma, el área geográfica no se mapea a la superficie terrestre real, sino al valor de la variable que se está estudiando (como la población, el PIB o los resultados electorales).

El concepto se remonta al siglo XIX, pero los cartogramas computacionales modernos fueron desarrollados y popularizados por geógrafos y cartógrafos como Waldo Tobler en la década de 1970.

### Descripción y Características

A diferencia de un Coropleta, que usa color para mostrar una variable sobre un mapa geográficamente preciso, el cartograma lo hace alterando la geometría del mapa en sí. El objetivo es dar más peso visual a las unidades con un valor más alto en la variable, resolviendo el problema común donde áreas geográficas muy grandes pero con valores bajos (ej. estados rurales) dominan visualmente un mapa estándar.

**Características distintivas:**

- **Distorsión del área:** Característica principal. El área de un polígono se escala para ser directamente proporcional a una variable.

- **Topología vs. Geometría:** Los cartogramas priorizan la topología (mantener la adyacencia y las conexiones entre vecinos) sobre la geometría (mantener la forma y el tamaño geográfico exacto).

- **Valor Comunicativo Inmediato:** Transmiten "dónde está la gente" o "dónde está el dinero" de una forma mucho más impactante que un mapa de coropletas.

### Funcionamiento

Existen tres tipos principales de cartogramas, cada uno con un enfoque diferente para manejar la distorsión:

- **Cartograma Contiguo (Contiguous):** El tipo más común y complejo. Las áreas geográficas se "inflan" o "desinflan" según la variable. El algoritmo intenta mantener la topología (los vecinos siguen siendo vecinos) y la forma general, pero esto inevitablemente resulta en una distorsión significativa de las formas.

- **Cartograma No Contiguo (Non-contiguous):** Cada área geográfica se escala en tamaño según la variable, pero se mantiene su forma geográfica original. Luego, las áreas se colocan en sus posiciones relativas, pero no se tocan, dejando espacios vacíos. Es más fácil de leer (las formas son reconocibles) pero rompe la adyacencia.

- **Cartograma de Dorling:** Reemplaza cada área geográfica con una forma simple, generalmente un círculo, cuyo tamaño es proporcional a la variable. Los círculos se disponen de manera que se aproximan a la ubicación geográfica original, a menudo "empujándose" entre sí.

### Ejemplos Típicos de Aplicación

Los cartogramas son extremadamente poderosos en el periodismo de datos, la ciencia política y la economía:

- **Elecciones:** Mostrar los resultados electorales donde el área de cada estado es proporcional a sus "votos electorales" o "población de votantes", en lugar de su tamaño geográfico (evitando el "mar de rojo/azul" engañoso).

- **Población:** El ejemplo clásico. Un mapa mundial donde el área de los países se escala a su población, mostrando el tamaño real de China e India en comparación con el de Rusia o Canadá.

- **Economía:** Visualizar el PIB global, donde los centros económicos como EE. UU., Europa y Asia Oriental se inflan masivamente.

- **Epidemiología:** Mapas de brotes de enfermedades donde las regiones se escalan según el número de casos.

---

## Tipo y estructura de datos adecuados

### Tipos de Datos

Los cartogramas requieren dos tipos de datos simultáneamente:

- **Datos Geoespaciales:** La geometría de las unidades, típicamente polígonos (países, estados, condados)

- **Datos Cuantitativos:** Una variable numérica (absoluta, no normalizada) que se usará para la distorsión

**Datos adecuados:**

- Valores **totales** y **absolutos** (ej. Población Total, PIB Total, Número de Votos)

- La variable debe ser **positiva**.

**No son adecuados para:**

- **Tasas o proporciones** (ej. % de pobreza, PIB per cápita). Usar una tasa para distorsionar el área no tiene sentido conceptual. Para eso se usa un mapa de coropletas

- Datos categóricos

### Estructura de Datos Requerida

La estructura ideal es un archivo de datos geoespaciales que ya contenga la variable cuantitativa como una columna en su tabla de atributos.

## Visualización práctica

### Descripción del Dataset

Para esta visualización, crearemos un cartograma contiguo de los Estados Unidos, donde el área de cada estado será distorsionada para ser proporcional a su población.

- **Datos Geográficos:** Usaremos el paquete tigris de R para obtener los polígonos (shapefiles) de los 50 estados de EE. UU.

- **Datos Cuantitativos:** Usaremos el dataset state.x77 incorporado en R, que incluye la población de los estados (estimación de 1975).

Uniremos estos dos datasets por el nombre del estado y luego usaremos el paquete cartogram para generar la geometría distorsionada.

```{r cartograma-usa, message=FALSE, warning=FALSE, cache=TRUE}
# Cargar librerías necesarias
library(sf)           # Para manejar datos geoespaciales (simple features)
library(tigris)       # Para descargar las geometrías de los estados
library(cartogram)    # El paquete que crea los cartogramas
library(ggplot2)      # Para visualizar el resultado
library(dplyr)        # Para manipulación de datos
library(stringr)      # Para limpieza de texto

# ============================================
# 1. OBTENER Y PREPARAR DATOS
# ============================================
datos_poblacion <- as.data.frame(state.x77) %>%
  tibble::rownames_to_column("NAME") %>%
  select(NAME, Population)

# Obtener los datos geoespaciales
us_states <- tigris::states(cb = TRUE, resolution = "20m") %>%
  filter(!STUSPS %in% c("AK", "HI", "PR", "VI", "GU", "AS", "MP"))

# ============================================
# 2. UNIR DATOS
# ============================================
states_con_poblacion <- us_states %>%
  left_join(datos_poblacion, by = "NAME") %>%
  filter(!is.na(Population)) %>%
  st_transform(5070) 

# ============================================
# 3. CONSTRUIR EL CARTOGRAMA
# ============================================
# Usar el namespace explícito para evitar conflictos
carto_us_poblacion <- cartogram::cartogram_cont(
  states_con_poblacion, 
  "Population",     
  itermax = 10      
)

# ============================================
# 4. VISUALIZAR
# ============================================
ggplot(carto_us_poblacion) +
  geom_sf(aes(fill = Population), color = "white", linewidth = 0.2) +
  scale_fill_viridis_c(
    labels = scales::comma,
    option = "plasma"  
  ) +
  labs(
    title = "Cartograma de Población de EE.UU. (1975)",
    subtitle = "El área de cada estado es proporcional a su población",
    fill = "Población"
  ) +
  theme_void() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14),
    plot.subtitle = element_text(hjust = 0.5, size = 11)
  )
```



## Conclusiones sobre Cartogramas

Los cartogramas son una herramienta de visualización fundamental para **corregir la percepción geoespacial** y revelar la verdadera magnitud de una variable. Son la técnica superior cuando el objetivo no es mostrar dónde ocurre algo en un sentido geográfico estricto, sino cuál es el peso real de esa variable (como población, riqueza o poder electoral).

Su efectividad se maximiza cuando:

1. Se trabaja con **datos de totales absolutos** (ej. población total, PIB total, número de votos).
2. El objetivo es **desafiar el sesgo visual** que introducen los mapas tradicionales, donde áreas geográficas extensas pero con valores bajos (ej. estados rurales, países desérticos) dominan la visualización.
3. Se busca una **comunicación impactante** que muestre la escala "humana" o "económica" de un fenómeno.

La principal contrapartida del cartograma es el **sacrificio de la precisión geométrica**. Al distorsionar el área, las formas familiares de los países o estados pueden volverse irreconocibles, lo que requiere un esfuerzo cognitivo inicial por parte del espectador.

Sin embargo, este "costo" es precisamente su fortaleza: el cartograma obliga al usuario a dejar de ver la geografía (la tierra) y a empezar a ver los datos (las personas, el dinero, los votos), proporcionando una perspectiva más justa y precisa de la distribución del fenómeno estudiado.